{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Librer\u00eda <code>ode</code>","text":"<p>Esta librer\u00eda provee de tres funciones que usan los m\u00e9todos num\u00e9ricos de <code>Euler</code> y <code>Runge-Kutta</code> para resolver ODE's</p> <p>Para ver el uso de las funciones ir al apartado <code>API</code></p> <p>A continuaci\u00f3n se explican un poco los tres m\u00e9todos utilizados en las funciones de esta librer\u00eda:</p>"},{"location":"#metodo-de-euler","title":"M\u00e9todo de Euler","text":"<p>El m\u00e9todo de Euler se basa en la expansi\u00f3n de Taylor de la funci\u00f3n x(t). Tenemos  Esto nos dice que para avanzar en el tiempo la funci\u00f3n por un paso h basta con utilizar la ecuaci\u00f3n:  </p>"},{"location":"#metodo-de-runge-kutta","title":"M\u00e9todo de Runge-Kutta","text":"<p>El m\u00e9todo de Runge-Kutta es en realidad una familia de m\u00e9todos de distinto orden que proveen una mejor aproximaci\u00f3n sin la necesidad de considerar ordenes m\u00e1s altos en la expansi\u00f3n de Taylor del m\u00e9todo de Euler. Este \u00faltimo punto se quiere evitar, dado que es complicado conocer la derivada de la funci\u00f3n que estamos evaluando en el lado derecho de la ODE.</p>"},{"location":"#metodo-de-runge-kutta-2rm-dorm-do-orden-rk2","title":"M\u00e9todo de Runge-Kutta 2^{\\rm do} Orden (RK2)","text":"<p>La idea del m\u00e9todo RK2 es utilizar el punto medio para evaluar el m\u00e9todo de Euler. Mientras que el m\u00e9todo de Euler se aplica en el punto t para evaluar la derivada para aproximar la funci\u00f3n en el punto x = t + h, el m\u00e9todo RK2 utiliza el punto medio t + h/2. De esta forma, se alcanza una mejor aproximaci\u00f3n para el mismo valor de h.</p> <p>El m\u00e9todo se deriva aplicando la serie de Taylor alrededor del punto medio t + h/2 para obtener el valor de la funci\u00f3n en el punto x(t + h). Tenemos  Similarmente, podemos hacer lo mismo para x(t), tal que  Al sustraer ambas ecuaciones obtenemos  Finalmente,  El t\u00e9rmino de orden h^2 desaparece y nuestra aproximaci\u00f3n tiene un error de orden h^3.</p> <p>El \u00fanico problema es que requerimos conocer el valor de la funci\u00f3n en el punto medio x(t + h/2), el cual desconocemos.</p> <p>Para aproximar este valor utilizamos el m\u00e9todo de Euler con un paso h/2, (x + h/2) = x(t) + \\frac{h}{2}f(x,t). De esta manera, obtenemos las ecuaciones del m\u00e9todo RK2:</p> <ul> <li>k_1 = hf(x,t),</li> <li>k_2 = hf\\left(x + \\frac{k_1}{2},t + \\frac{h}{2}\\right)</li> <li>x(t + h) = x(t) + k_2</li> </ul>"},{"location":"#metodo-de-runge-kutta-de-4rm-torm-to-orden","title":"M\u00e9todo de Runge-Kutta de 4^{\\rm to} Orden","text":"<p>La metodolog\u00eda anterior se puede aplicar a\u00fan a m\u00e1s puntos ubicados entre x(t) y x(t + h) realizando expansiones de Taylor. De esta forma se pueden agrupar t\u00e9rminos de orden h^3, h^4, etc; para cancelar dichas expresiones. </p> <p>El \u00e1lgebra para encontrar las ecuaciones de 4^{\\rm to} orden es tediosa, pero el resultado final es</p> <ul> <li>k_1 = hf(x, t),</li> <li>k_2 = hf\\left(x + \\frac{k_1}{2}, t+\\frac{h}2\\right),</li> <li>k_3 = hf\\left(x + \\frac{k_2}{2}, t+\\frac{h}2\\right),</li> <li>k_4 = hf\\left(x + k_3, t + h \\right),</li> <li>x(t+h) = x(t) + \\frac{1}{6}(k_1 + 2 k_2 + 2k_3 + k_4).</li> </ul>"},{"location":"reference/","title":"M\u00f3dulo ODE","text":"<p>Provee de m\u00e9todos num\u00e9ricos para resolver ODE's.</p> <p>Este m\u00f3dulo le permite al usuario resolver num\u00e9ricamente ecuaciones diferenciales ordinarias.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ode\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; def f(x, t):\n...     return x + t\n&gt;&gt;&gt; ode.RK2(f, 10, 0.0, 0.0, 10.0)\narray([0.00000000e+00, 5.00000000e-01, 3.41666667e+00, 1.23750000e+01,\n       3.64375000e+01, 9.82604167e+01, 2.54484375e+02, 6.46710937e+02,\n       1.62894401e+03, 4.08619336e+03])\n</code></pre> <p>El m\u00f3dulo contiene las siguientes funciones:</p> <ul> <li><code>Euler(f, N, xi, ti, tf)</code> - Retorna un arreglo con los resultados num\u00e9ricos de la ODE dada por <code>f</code> utilizando el m\u00e9todo de <code>Euler</code>.</li> <li><code>RK2(f, N, xi, ti, tf)</code> - Retorna un arreglo con los resultados num\u00e9ricos de la ODE dada por <code>f</code> utilizando el m\u00e9todo de <code>Runge-Kutta 2</code>.</li> <li><code>RK4(f, N, xi, ti, tf)</code> - Retorna un arreglo con los resultados num\u00e9ricos de la ODE dada por <code>f</code> utilizando el m\u00e9todo de <code>Runge-Kutta 4</code>.</li> </ul>"},{"location":"reference/#ode.ode.Euler","title":"<code>Euler(f, N, xi, ti, tf)</code>","text":"<p>Calcula los resultados num\u00e9ricos de una ODE usando el m\u00e9todo de Euler</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; def f(x, t):\n...     return x + t\n&gt;&gt;&gt; Euler(f, 10 , 0.0, 0.0, 10.0)\narray([  0.        ,   0.        ,   1.11111111,   4.44444444,\n        12.22222222,  28.88888889,  63.33333333, 133.33333333,\n       274.44444444, 557.77777778])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>function</code> <p>La funci\u00f3n a ser resuelta.</p> required <code>N</code> <code>int</code> <p>N\u00famero de pasos en la variable independiente.</p> required <code>xi</code> <code>float</code> <p>Valor inicial de la variable dependiente.</p> required <code>ti</code> <code>float</code> <p>Valor inicial de la variable independiente.</p> required <code>tf</code> <code>float</code> <p>Valor final de la variable independiente.</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Un arreglo de numpy con los resultados num\u00e9ricos de la variable dependiente para cada vaalor de la variable independiente.</p> Source code in <code>ode/ode.py</code> <pre><code>def Euler(f, N, xi, ti, tf):\n\n    \"\"\"Calcula los resultados num\u00e9ricos de una ODE usando el m\u00e9todo de Euler\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; def f(x, t):\n        ...     return x + t\n        &gt;&gt;&gt; Euler(f, 10 , 0.0, 0.0, 10.0)\n        array([  0.        ,   0.        ,   1.11111111,   4.44444444,\n                12.22222222,  28.88888889,  63.33333333, 133.33333333,\n               274.44444444, 557.77777778])\n\n    Args:\n        f (function): La funci\u00f3n a ser resuelta.\n        N (int): N\u00famero de pasos en la variable independiente.\n        xi (float): Valor inicial de la variable dependiente.\n        ti (float): Valor inicial de la variable independiente.\n        tf (float): Valor final de la variable independiente.\n\n    Returns:\n        ndarray: Un arreglo de numpy con los resultados num\u00e9ricos de la variable dependiente para cada vaalor de la variable independiente.\n    \"\"\"\n\n    h = (tf-ti)/N\n    t = np.linspace(ti, tf, N)\n    x = np.zeros(len(t))\n    x[0] = xi\n\n    for i in range(len(t)-1):\n\n        x[i+1] = x[i] + h * f(x[i], t[i])\n\n    return x\n</code></pre>"},{"location":"reference/#ode.ode.RK2","title":"<code>RK2(f, N, xi, ti, tf)</code>","text":"<p>Calcula los resultados num\u00e9ricos de una ODE usando el m\u00e9todo de Euler</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; def f(x, t):\n...     return x + t\n&gt;&gt;&gt; RK2(f, 10, 0.0, 0.0, 10.0)\narray([0.00000000e+00, 5.00000000e-01, 3.41666667e+00, 1.23750000e+01,\n       3.64375000e+01, 9.82604167e+01, 2.54484375e+02, 6.46710937e+02,\n       1.62894401e+03, 4.08619336e+03])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>function</code> <p>La funci\u00f3n a ser resuelta.</p> required <code>N</code> <code>int</code> <p>N\u00famero de pasos en la variable independiente.</p> required <code>xi</code> <code>float</code> <p>Valor inicial de la variable dependiente.</p> required <code>ti</code> <code>float</code> <p>Valor inicial de la variable independiente.</p> required <code>tf</code> <code>float</code> <p>Valor final de la variable independiente.</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Un arreglo de numpy con los resultados num\u00e9ricos de la variable dependiente para cada vaalor de la variable independiente.</p> Source code in <code>ode/ode.py</code> <pre><code>def RK2(f, N, xi, ti, tf):\n\n    \"\"\"Calcula los resultados num\u00e9ricos de una ODE usando el m\u00e9todo de Euler\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; def f(x, t):\n        ...     return x + t\n        &gt;&gt;&gt; RK2(f, 10, 0.0, 0.0, 10.0)\n        array([0.00000000e+00, 5.00000000e-01, 3.41666667e+00, 1.23750000e+01,\n               3.64375000e+01, 9.82604167e+01, 2.54484375e+02, 6.46710937e+02,\n               1.62894401e+03, 4.08619336e+03])\n\n    Args:\n        f (function): La funci\u00f3n a ser resuelta.\n        N (int): N\u00famero de pasos en la variable independiente.\n        xi (float): Valor inicial de la variable dependiente.\n        ti (float): Valor inicial de la variable independiente.\n        tf (float): Valor final de la variable independiente.\n\n    Returns:\n        ndarray: Un arreglo de numpy con los resultados num\u00e9ricos de la variable dependiente para cada vaalor de la variable independiente.\n    \"\"\"\n\n    h = (tf-ti)/N\n    t = np.linspace(ti, tf, N)\n    x = np.zeros(len(t))\n    x[0] = xi\n\n    for i in range(len(t)-1):\n\n        k1 = h*f(x[i],t[i])\n        k2 = h*f(x[i] + k1/2, t[i] + h/2)\n\n        x[i+1] = x[i] + k2\n\n    return x\n</code></pre>"},{"location":"reference/#ode.ode.RK4","title":"<code>RK4(f, N, xi, ti, tf)</code>","text":"<p>Calcula los resultados num\u00e9ricos de una ODE usando el m\u00e9todo de Euler</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; def f(x, t):\n...     return x + t\n&gt;&gt;&gt; RK4(f, 10, 0.0, 0.0, 10.0)\narray([0.00000000e+00, 7.08333333e-01, 4.52488426e+00, 1.67595245e+01,\n       5.17931566e+01, 1.48574058e+02, 4.12587149e+02, 1.12952075e+03,\n       3.07311407e+03, 8.33891079e+03])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>function</code> <p>La funci\u00f3n a ser resuelta.</p> required <code>N</code> <code>int</code> <p>N\u00famero de pasos en la variable independiente.</p> required <code>xi</code> <code>float</code> <p>Valor inicial de la variable dependiente.</p> required <code>ti</code> <code>float</code> <p>Valor inicial de la variable independiente.</p> required <code>tf</code> <code>float</code> <p>Valor final de la variable independiente.</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Un arreglo de numpy con los resultados num\u00e9ricos de la variable dependiente para cada vaalor de la variable independiente.</p> Source code in <code>ode/ode.py</code> <pre><code>def RK4(f, N, xi, ti, tf):\n\n    \"\"\"Calcula los resultados num\u00e9ricos de una ODE usando el m\u00e9todo de Euler\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; def f(x, t):\n        ...     return x + t\n        &gt;&gt;&gt; RK4(f, 10, 0.0, 0.0, 10.0)\n        array([0.00000000e+00, 7.08333333e-01, 4.52488426e+00, 1.67595245e+01,\n               5.17931566e+01, 1.48574058e+02, 4.12587149e+02, 1.12952075e+03,\n               3.07311407e+03, 8.33891079e+03])\n\n    Args:\n        f (function): La funci\u00f3n a ser resuelta.\n        N (int): N\u00famero de pasos en la variable independiente.\n        xi (float): Valor inicial de la variable dependiente.\n        ti (float): Valor inicial de la variable independiente.\n        tf (float): Valor final de la variable independiente.\n\n    Returns:\n        ndarray: Un arreglo de numpy con los resultados num\u00e9ricos de la variable dependiente para cada vaalor de la variable independiente.\n    \"\"\"\n\n    h = (tf-ti)/N\n    t = np.linspace(ti, tf, N)\n    x = np.zeros(len(t))\n    x[0] = xi\n\n    for i in range(len(t)-1):\n\n        k1 = h*f(x[i], t[i])\n        k2 = h*f(x[i] + k1/2, t[i] + h/2)\n        k3 = h*f(x[i] + k2/2, t[i] + h/2)\n        k4 = h*f(x[i] + k3, t[i]+h)\n\n        x[i+1] = x[i] + (1/6)*(k1+2*k2+2*k3+k4)\n\n    return x\n</code></pre>"}]}